# -*- indent-tabs-mode: t -*-

# Soya 3D tutorial
# Copyright (C) 2001-2010 Jean-Baptiste LAMY
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


# shader-1: Vertex shader : woobling effect

# Imports sys, os modules and the Soya module.

import sys, os, os.path, soya

# Initializes Soya (creates and displays the 3D window).

soya.init()

soya.path.append(os.path.join(os.path.dirname(sys.argv[0]), "data"))

# Creates a scene.

scene = soya.World()

# Loads the sword model (from file "tutorial/data/models/sword.data").

sword_model = soya.Model.get("sword")

# Create the models.

sword = soya.Body(scene, sword_model)
sword.x =  1.0
sword.y = -0.5
sword.rotate_y(90.0)

normal_sword = soya.Body(scene, sword_model)
normal_sword.x = 1.0
normal_sword.y = 0.5
normal_sword.rotate_y(90.0)

# Creates a light and a camera.

light = soya.Light(scene)
light.set_xyz(0.5, 0.0, 2.0)
camera = soya.Camera(scene)
camera.z = 2.0
soya.set_root_widget(camera)


# Shader must be written in OpenGL ARB shading language.
# Attention : the shader code MUST start by !!ARBvp1.0 at the first character ;
# in Python, a common error is to write :
#
#    shader_code = """
#    !!ARBvp1.0
#    [...]
#    """
#
# And that does not work !


# Basic No-op shader that does nothing :
shader_code = """!!ARBvp1.0
TEMP vertexClip;
DP4 vertexClip.x, state.matrix.mvp.row[0], vertex.position;
DP4 vertexClip.y, state.matrix.mvp.row[1], vertex.position;
DP4 vertexClip.z, state.matrix.mvp.row[2], vertex.position;
DP4 vertexClip.w, state.matrix.mvp.row[3], vertex.position;
MOV result.position, vertexClip;
MOV result.color, vertex.position;
MOV result.texcoord, vertex.texcoord;
END
"""

# Woobling effect shader.
# The shader local parameter 0 (program.local[0] in the code) is automatically
# defined and handled by Soya, and corresponds to the time
# (in round, starting when the shader is associated to the body).

shader_code = """!!ARBvp1.0
TEMP vertexClip;
TEMP angle;
TEMP pos;
MOV pos, vertex.position;
MOV angle, program.local[0];
MUL angle, angle, 0.1;
ADD angle, angle, pos.y;


# Code generated by Cg for computing sinus and cosinus
PARAM c[4] = { { 1, -24.980801, 60.145809, 0.15915491 },
		{ 0.25, 0.5, 0.75, 1 },
		{ -85.453789, 64.939346, -19.73921, 1 },
		{ 1, -1 } };
TEMP R0;
TEMP R1;
TEMP R2;
TEMP sincos;
MOV R0.x, c[0].w;
MUL R0.x, R0, angle;
FRC R1.z, R0.x;
SLT R0, R1.z, c[1];
ADD R2.xyz, R0.yzww, -R0;
MOV R0.yzw, R2.xxyz;
DP3 R1.x, R2, c[1].yyww;
DP4 R1.y, R0, c[1].xxzz;
ADD R1.xy, R1.z, -R1;
MUL R2.xy, R1, R1;
MUL R2.zw, R2.xyxy, R2.xyxy;
MUL R1, R2.zzww, c[0].yzyz;
ADD R1, R1, c[2].xyxy;
MAD R1, R1, R2.zzww, c[2].zwzw;
MAD R1.xy, R1.xzzw, R2, R1.ywzw;
DP4 R1.w, R0, c[3].xxyy;
DP4 R1.z, R0, c[3].xyyx;
MUL sincos, R1.wzzw, R1.yxzw;
#sin = sincos.x,  cos = sincos.y

MUL sincos.x, sincos.x, 0.3;
ADD pos.x, sincos.x, pos.x;
ADD pos.x, -0.15, pos.x;
DP4 vertexClip.x, state.matrix.mvp.row[0], pos;
DP4 vertexClip.y, state.matrix.mvp.row[1], pos;
DP4 vertexClip.z, state.matrix.mvp.row[2], pos;
DP4 vertexClip.w, state.matrix.mvp.row[3], pos;
MOV result.position, vertexClip;
MOV result.color, vertex.color;
MOV result.texcoord, vertex.texcoord;
END
"""

# One can use Cg compiler for generating shader as following :
#
#   cgc -oglsl -profile arbvp1 -entry main cg_source.cg
#
# Cg is not included in Soya because it is not Free Software !


shader = soya.ARBShaderProgram(soya.SHADER_TYPE_VERTEX, shader_code)

sword.add_deform(shader())


# Uncomment this line to save a 320x240 screenshot in the results directory.

#soya.render(); soya.screenshot().resize((320, 240)).save(os.path.join(os.path.dirname(sys.argv[0]), "results", os.path.basename(sys.argv[0])[:-3] + ".jpeg"))

# Creates an 'MainLoop' for the scene.

soya.MainLoop(scene).main_loop()


